"use client";

import { useState, useCallback, useEffect } from "react";
import { LAMPORTS_PER_SOL } from "@solana/web3.js";
import { useL2Wallet } from "@/contexts/L2WalletContext";
import {
  hexToBytes,
  randomBytes,
  bytesToHex,
  encryptNote,
  x25519PublicKey,
} from "@zelana/sdk";
import type { ScannedNote, ShieldedRequest } from "@zelana/sdk";
import {
  initOwnershipProver,
  isProverInitialized,
  computeNullifier as wasmComputeNullifier,
  computeCommitment as wasmComputeCommitment,
  computeBlindedProxy as wasmComputeBlindedProxy,
  generateBlinding,
} from "@/lib/ownership-prover";
import {
  generateOwnershipProof as serverGenerateProof,
  hexToBytes as proofHexToBytes,
  toDecimalString,
  hexToDecimalField,
  checkProverHealth,
} from "@/lib/proof-client";

/**
 * Convert a hex string to 32-byte Uint8Array
 * The WASM prover returns field elements as hex strings (without 0x prefix)
 * The server API also returns commitment/blinding as hex strings
 */
function hexToBytes32(hex: string): Uint8Array {
  const cleanHex = hex.startsWith('0x') ? hex.slice(2) : hex;
  if (cleanHex.length !== 64) {
    throw new Error(`Expected 64 hex chars for 32 bytes, got ${cleanHex.length}`);
  }
  const bytes = new Uint8Array(32);
  for (let i = 0; i < 32; i++) {
    bytes[i] = parseInt(cleanHex.substring(i * 2, i * 2 + 2), 16);
  }
  return bytes;
}

type ShieldedTab = 'shield' | 'transfer' | 'unshield';

/**
 * Tab button component
 */
function TabButton({ 
  active, 
  onClick, 
  children 
}: { 
  active: boolean; 
  onClick: () => void; 
  children: React.ReactNode 
}) {
  return (
    <button
      onClick={onClick}
      className={`flex-1 px-3 py-2 text-xs font-medium rounded-lg transition-all ${
        active
          ? 'bg-purple-500/20 text-purple-400 border border-purple-500/30'
          : 'text-white/60 hover:text-white hover:bg-white/5'
      }`}
    >
      {children}
    </button>
  );
}

/**
 * ShieldedTransfer component for privacy-preserving transactions
 * 
 * Features:
 * - Shield: Convert transparent zeSOL to shielded (private) zeSOL
 * - Transfer: Send shielded zeSOL to another shielded address
 * - Unshield: Convert shielded zeSOL back to transparent balance
 * 
 * Note: The sequencer currently uses mock proof verification for MVP.
 * In production, real ZK proofs would be generated by the prover coordinator.
 */
export function ShieldedTransfer() {
  const { isReady, client, shieldedKeys, shieldedAddress, l2Address } = useL2Wallet();
  
  // Tab state
  const [activeTab, setActiveTab] = useState<ShieldedTab>('shield');
  
  // Form state
  const [amount, setAmount] = useState('');
  const [recipient, setRecipient] = useState('');
  const [sending, setSending] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);
  
  // Balance state
  const [shieldedBalance, setShieldedBalance] = useState<bigint | null>(null);
  const [transparentBalance, setTransparentBalance] = useState<bigint | null>(null);
  const [balanceLoading, setBalanceLoading] = useState(false);
  const [noteCount, setNoteCount] = useState(0);
  const [ownedNotes, setOwnedNotes] = useState<ScannedNote[]>([]);
  
  // WASM prover state (for witness generation)
  const [proverReady, setProverReady] = useState(false);
  // Server prover state (for Groth16 proof generation)
  const [serverProverReady, setServerProverReady] = useState(false);
  const [proverError, setProverError] = useState<string | null>(null);
  
  // Initialize WASM ownership prover and check server prover health on mount
  useEffect(() => {
    // Initialize WASM prover (for MiMC witness generation)
    if (isProverInitialized()) {
      setProverReady(true);
    } else {
      initOwnershipProver()
        .then(() => {
          setProverReady(true);
          console.log('[ShieldedTransfer] WASM ownership prover initialized');
        })
        .catch((err) => {
          console.error('[ShieldedTransfer] Failed to initialize WASM prover:', err);
          setProverError('Failed to load cryptographic prover');
        });
    }
    
    // Check server prover health (prover-coordinator)
    checkProverHealth()
      .then((healthy) => {
        setServerProverReady(healthy);
        if (healthy) {
          console.log('[ShieldedTransfer] Server prover (prover-coordinator) is healthy');
        } else {
          console.warn('[ShieldedTransfer] Server prover not available, will use mock proofs');
        }
      })
      .catch(() => {
        console.warn('[ShieldedTransfer] Failed to check server prover health');
        setServerProverReady(false);
      });
  }, []);
  
  // Fetch transparent L2 balance
  const fetchTransparentBalance = useCallback(async () => {
    if (!client || !l2Address) {
      setTransparentBalance(null);
      return;
    }
    
    try {
      const account = await client.getAccountFor(l2Address.toString());
      setTransparentBalance(account.balance);
    } catch (e) {
      console.error('Failed to fetch transparent balance:', e);
      setTransparentBalance(null);
    }
  }, [client, l2Address]);
  
  // Fetch shielded balance by scanning notes via API
  const fetchShieldedBalance = useCallback(async () => {
    if (!client || !shieldedKeys) {
      setShieldedBalance(null);
      setOwnedNotes([]);
      return;
    }
    
    setBalanceLoading(true);
    try {
      // Use API scanning - backend decrypts notes with X25519+ChaCha20
      // and verifies commitments with MiMC (matching our WASM prover)
      const result = await client.apiClient.scanNotes(
        shieldedKeys.viewingKey,   // decryption key for X25519+ChaCha20
        shieldedKeys.publicKey,    // owner public key (MiMC-derived)
        0,                         // from position
        1000                       // limit
      );
      
      // Sum up note values
      const total = result.notes.reduce((sum, n) => sum + n.value, 0n);
      setShieldedBalance(total);
      setNoteCount(result.notes.length);
      setOwnedNotes(result.notes);
      
      console.log(`[ShieldedBalance] Scanned ${result.notes.length} notes, total: ${total} lamports`);
    } catch (e) {
      console.error('Failed to scan shielded notes:', e);
      setShieldedBalance(0n);
      setNoteCount(0);
      setOwnedNotes([]);
    } finally {
      setBalanceLoading(false);
    }
  }, [client, shieldedKeys]);
  
  // Fetch both balances
  const fetchBalances = useCallback(async () => {
    await Promise.all([fetchTransparentBalance(), fetchShieldedBalance()]);
  }, [fetchTransparentBalance, fetchShieldedBalance]);
  
  useEffect(() => {
    fetchBalances();
  }, [fetchBalances]);

  const shieldedBalanceInSol = shieldedBalance !== null ? Number(shieldedBalance) / LAMPORTS_PER_SOL : 0;
  const transparentBalanceInSol = transparentBalance !== null ? Number(transparentBalance) / LAMPORTS_PER_SOL : 0;
  
  // Clear form when switching tabs
  useEffect(() => {
    setAmount('');
    setRecipient('');
    setError(null);
    setSuccess(null);
  }, [activeTab]);
  
  /**
   * Generate a Groth16 ownership proof for spending a note via server
   * Falls back to mock proof if server prover is not available
   */
  const generateSpendProof = useCallback(async (
    spendingKeyHex: string,
    noteValue: bigint,
    noteBlinding: string,
    notePosition: bigint,
    commitment: string,
    nullifier: string
  ): Promise<Uint8Array> => {
    if (!serverProverReady) {
      console.warn('[SpendProof] Server prover not available, using mock proof');
      return new Uint8Array([1, 2, 3, 4]);
    }
    
    try {
      // Compute blinded proxy using WASM prover (returns hex string)
      const blindedProxy = await wasmComputeBlindedProxy(commitment, notePosition);
      
      // Generate real Groth16 proof via server (prover-coordinator)
      // IMPORTANT: WASM prover returns hex strings, but Noir circuits expect decimal strings
      // Convert all hex values to decimal field elements for the prover
      const result = await serverGenerateProof({
        spending_key: toDecimalString(BigInt('0x' + spendingKeyHex)),
        note_value: toDecimalString(noteValue),
        note_blinding: toDecimalString(BigInt('0x' + noteBlinding)),
        note_position: toDecimalString(notePosition),
        commitment: hexToDecimalField(commitment),      // Convert hex to decimal
        nullifier: hexToDecimalField(nullifier),        // Convert hex to decimal
        blinded_proxy: hexToDecimalField(blindedProxy), // Convert hex to decimal
      });
      
      console.log(`[SpendProof] Generated Groth16 proof in ${result.proving_time_ms}ms (388 bytes)`);
      return proofHexToBytes(result.proof_bytes);
    } catch (err) {
      console.error('[SpendProof] Server proof generation failed, using mock:', err);
      return new Uint8Array([1, 2, 3, 4]);
    }
  }, [serverProverReady]);
  
  // Handle Shield: transparent -> shielded
  const handleShield = async () => {
    setError(null);
    setSuccess(null);
    
    if (!client || !shieldedKeys) {
      setError('Wallet not connected or shielded keys not derived');
      return;
    }
    
    const amountNum = parseFloat(amount);
    if (!amountNum || amountNum <= 0) {
      setError('Enter a valid amount');
      return;
    }
    
    const amountLamports = BigInt(Math.floor(amountNum * LAMPORTS_PER_SOL));
    
    // Check transparent balance
    if (transparentBalance === null || amountLamports > transparentBalance) {
      setError('Insufficient transparent balance');
      return;
    }
    
    setSending(true);
    
    try {
      // Generate random blinding factor for the note
      const blindingHex = generateBlinding();
      const blindingBytes = hexToBytes(blindingHex);
      const ownerPkHex = shieldedAddress; // Already a hex string from WASM prover
      
      // Compute commitment using WASM prover (MiMC - matches Noir circuits)
      // WASM prover returns hex string (without 0x prefix)
      const commitmentHex = await wasmComputeCommitment(ownerPkHex, amountLamports, blindingHex);
      const outputCommitment = hexToBytes32(commitmentHex);
      
      // Derive X25519 public key from viewing key for encryption
      // The viewing key is the X25519 secret key, and we encrypt to the corresponding public key
      const viewingPk = x25519PublicKey(shieldedKeys.viewingKey);
      
      // Encrypt the note for ourselves using X25519+ChaCha20-Poly1305
      // This allows us to later decrypt and scan for our notes
      const encrypted = encryptNote(
        amountLamports,
        blindingBytes,
        viewingPk,
        undefined // No memo
      );
      
      // For shielding, we use a dummy nullifier (no input being spent from shielded pool)
      // The sequencer should recognize this as a "shield" operation
      // NOTE: In a real implementation, this would require a separate endpoint or transaction type
      const request: ShieldedRequest = {
        proof: new Uint8Array([1, 2, 3, 4]), // Mock proof
        nullifier: randomBytes(32), // Dummy nullifier for shield operation
        commitment: outputCommitment,
        ciphertext: encrypted.ciphertext,
        ephemeralKey: encrypted.ephemeralPk,
        nonce: encrypted.nonce, // Add nonce to request
        // Shield hints: debit transparent account
        shieldFrom: hexToBytes32(l2Address!.toString()),
        shieldAmount: amountLamports,
      };
      
      // Submit shielded transaction
      const response = await client.apiClient.submitShielded(request);
      
      if (!response.accepted) {
        throw new Error(`Shield transaction rejected: ${response.message}`);
      }
      
      // Optimistic update: reduce transparent balance
      if (transparentBalance !== null) {
        setTransparentBalance(transparentBalance - amountLamports);
      }
      
      // Optimistic update: increase shielded balance
      if (shieldedBalance !== null) {
        setShieldedBalance(shieldedBalance + amountLamports);
        setNoteCount(noteCount + 1);
      }
      
      setSuccess(`Shielded ${amountNum.toFixed(4)} zeSOL! TX: ${response.txHash.slice(0, 16)}...`);
      
      // Refresh balances after a short delay
      setTimeout(() => {
        fetchBalances();
      }, 1500);
      
      // Clear form
      setAmount('');
      
    } catch (err: unknown) {
      const message = err instanceof Error ? err.message : 'Unknown error';
      setError(message);
    } finally {
      setSending(false);
    }
  };
  
  // Handle Transfer: shielded -> shielded
  const handleTransfer = async () => {
    setError(null);
    setSuccess(null);
    
    if (!client || !shieldedKeys) {
      setError('Wallet not connected or shielded keys not derived');
      return;
    }
    
    if (!proverReady) {
      setError('Cryptographic prover not ready. Please wait or refresh the page.');
      return;
    }
    
    const amountNum = parseFloat(amount);
    if (!amountNum || amountNum <= 0) {
      setError('Enter a valid amount');
      return;
    }
    
    const amountLamports = BigInt(Math.floor(amountNum * LAMPORTS_PER_SOL));
    
    if (!recipient || recipient.length !== 64) {
      setError('Enter a valid recipient shielded address (64 hex characters)');
      return;
    }
    
    // Check shielded balance
    if (shieldedBalance === null || amountLamports > shieldedBalance) {
      setError('Insufficient shielded balance');
      return;
    }
    
    setSending(true);
    
    try {
      // Parse recipient public key
      const recipientPk = hexToBytes(recipient);
      if (recipientPk.length !== 32) {
        throw new Error('Invalid recipient address length');
      }
      
      // Find notes to spend (simple greedy selection)
      let remaining = amountLamports;
      const inputNotes: ScannedNote[] = [];
      for (const note of ownedNotes) {
        if (remaining <= 0n) break;
        inputNotes.push(note);
        remaining -= note.value;
      }
      
      if (remaining > 0n) {
        throw new Error('Could not find enough notes to cover the amount');
      }
      
      // Calculate change
      const totalInput = inputNotes.reduce((sum, n) => sum + n.value, 0n);
      const change = totalInput - amountLamports;
      
      // Create output note for recipient using WASM prover
      // WASM prover returns hex string (without 0x prefix)
      const outputBlindingHex = generateBlinding();
      const outputCommitmentHex = await wasmComputeCommitment(recipient, amountLamports, outputBlindingHex);
      const outputCommitment = hexToBytes32(outputCommitmentHex);
      
      // For each input, compute nullifier and submit a shielded tx
      for (const inputNote of inputNotes) {
        // Convert spending key to hex for WASM prover
        const spendingKeyHex = bytesToHex(shieldedKeys.spendingKey);
        // inputNote.commitment is hex (from server scan API)
        const commitmentHex = inputNote.commitment;
        
        // Compute nullifier using WASM prover (returns hex string)
        const nullifierHex = await wasmComputeNullifier(
          spendingKeyHex,
          commitmentHex,
          BigInt(inputNote.position)
        );
        
        // Convert hex string to bytes
        const nullifierBytes = hexToBytes32(nullifierHex);
        
        // Generate real ZK ownership proof (or mock if Noir prover not ready)
        const proof = await generateSpendProof(
          spendingKeyHex,
          inputNote.value,
          inputNote.blinding, // hex from scan API
          BigInt(inputNote.position),
          commitmentHex,
          nullifierHex
        );
        
        // For the output note, we need the recipient's X25519 viewing public key for encryption
        // NOTE: Currently we use a placeholder - in production, the recipient would share their viewing key
        // TODO: Add recipient viewing key to the transfer UI
        const ephemeralKey = randomBytes(32);
        const ciphertext = new Uint8Array(64); // Placeholder - real impl needs recipient's viewing key
        
        const request: ShieldedRequest = {
          proof: proof,
          nullifier: nullifierBytes,
          commitment: outputCommitment,
          ciphertext: ciphertext,
          ephemeralKey: ephemeralKey,
          nonce: new Uint8Array(12), // Placeholder nonce
        };
        
        const response = await client.apiClient.submitShielded(request);
        
        if (!response.accepted) {
          throw new Error(`Shielded transaction rejected: ${response.message}`);
        }
        
        // Handle change - submit change note back to ourselves (properly encrypted)
        if (change > 0n) {
          const changeBlindingHex = generateBlinding();
          const changeBlindingBytes = hexToBytes(changeBlindingHex);
          // WASM prover returns hex string
          const changeCommitmentHex = await wasmComputeCommitment(shieldedAddress, change, changeBlindingHex);
          const changeCommitment = hexToBytes32(changeCommitmentHex);
          
          // Encrypt change note for ourselves
          const viewingPk = x25519PublicKey(shieldedKeys.viewingKey);
          const changeEncrypted = encryptNote(
            change,
            changeBlindingBytes,
            viewingPk,
            undefined
          );
          
          const changeRequest: ShieldedRequest = {
            proof: new Uint8Array([1, 2, 3, 4]),
            nullifier: randomBytes(32),
            commitment: changeCommitment,
            ciphertext: changeEncrypted.ciphertext,
            ephemeralKey: changeEncrypted.ephemeralPk,
            nonce: changeEncrypted.nonce,
          };
          
          const changeResponse = await client.apiClient.submitShielded(changeRequest);
          
          if (!changeResponse.accepted) {
            console.warn('Change note submission failed:', changeResponse.message);
          }
        }
        
        setSuccess(`Shielded transfer submitted! TX: ${response.txHash.slice(0, 16)}...`);
      }
      
      // Refresh balance
      await fetchShieldedBalance();
      
      // Clear form
      setAmount('');
      setRecipient('');
      
    } catch (err: unknown) {
      const message = err instanceof Error ? err.message : 'Unknown error';
      setError(message);
    } finally {
      setSending(false);
    }
  };
  
  // Handle Unshield: shielded -> transparent
  const handleUnshield = async () => {
    setError(null);
    setSuccess(null);
    
    if (!client || !shieldedKeys) {
      setError('Wallet not connected or shielded keys not derived');
      return;
    }
    
    if (!proverReady) {
      setError('Cryptographic prover not ready. Please wait or refresh the page.');
      return;
    }
    
    const amountNum = parseFloat(amount);
    if (!amountNum || amountNum <= 0) {
      setError('Enter a valid amount');
      return;
    }
    
    const amountLamports = BigInt(Math.floor(amountNum * LAMPORTS_PER_SOL));
    
    // Check shielded balance
    if (shieldedBalance === null || amountLamports > shieldedBalance) {
      setError('Insufficient shielded balance');
      return;
    }
    
    setSending(true);
    
    try {
      // Find notes to spend
      let remaining = amountLamports;
      const inputNotes: ScannedNote[] = [];
      for (const note of ownedNotes) {
        if (remaining <= 0n) break;
        inputNotes.push(note);
        remaining -= note.value;
      }
      
      if (remaining > 0n) {
        throw new Error('Could not find enough notes to cover the amount');
      }
      
      // Calculate change
      const totalInput = inputNotes.reduce((sum, n) => sum + n.value, 0n);
      const change = totalInput - amountLamports;
      
      // For unshield, we spend shielded notes but create an "exit" commitment
      // that credits the transparent balance. This is a simplified demo version.
      // NOTE: In production, this requires a specific unshield transaction type
      
      for (const inputNote of inputNotes) {
        const spendingKeyHex = bytesToHex(shieldedKeys.spendingKey);
        // inputNote.commitment is hex (from server scan API)
        const commitmentHex = inputNote.commitment;
        
        // Compute nullifier using WASM prover (returns hex string)
        const nullifierHex = await wasmComputeNullifier(
          spendingKeyHex,
          commitmentHex,
          BigInt(inputNote.position)
        );
        
        const nullifierBytes = hexToBytes32(nullifierHex);
        
        // Generate real ZK ownership proof (or mock if Noir prover not ready)
        const proof = await generateSpendProof(
          spendingKeyHex,
          inputNote.value,
          inputNote.blinding, // hex from scan API
          BigInt(inputNote.position),
          commitmentHex,
          nullifierHex
        );
        
        // For unshield, we create a "burn" commitment (zero value placeholder)
        // The sequencer should recognize this pattern and credit transparent balance
        const burnBlindingHex = generateBlinding();
        const burnBlindingBytes = hexToBytes(burnBlindingHex);
        // WASM prover returns hex string
        const burnCommitmentHex = await wasmComputeCommitment(shieldedAddress, 0n, burnBlindingHex);
        const burnCommitment = hexToBytes32(burnCommitmentHex);
        
        // Encrypt burn note (even though value is 0, we need proper encryption for consistency)
        const viewingPk = x25519PublicKey(shieldedKeys.viewingKey);
        const burnEncrypted = encryptNote(
          0n,
          burnBlindingBytes,
          viewingPk,
          undefined
        );
        
        const request: ShieldedRequest = {
          proof: proof,
          nullifier: nullifierBytes,
          commitment: burnCommitment,
          ciphertext: burnEncrypted.ciphertext,
          ephemeralKey: burnEncrypted.ephemeralPk,
          nonce: burnEncrypted.nonce,
          // Unshield hints: credit transparent account
          unshieldTo: hexToBytes32(l2Address!.toString()),
          unshieldAmount: inputNote.value,
        };
        
        const response = await client.apiClient.submitShielded(request);
        
        if (!response.accepted) {
          throw new Error(`Unshield transaction rejected: ${response.message}`);
        }
        
        // Handle change - keep it in shielded pool (properly encrypted)
        if (change > 0n) {
          const changeBlindingHex = generateBlinding();
          const changeBlindingBytes = hexToBytes(changeBlindingHex);
          // WASM prover returns hex string
          const changeCommitmentHex = await wasmComputeCommitment(shieldedAddress, change, changeBlindingHex);
          const changeCommitment = hexToBytes32(changeCommitmentHex);
          
          // Encrypt change note for ourselves
          const changeEncrypted = encryptNote(
            change,
            changeBlindingBytes,
            viewingPk,
            undefined
          );
          
          const changeRequest: ShieldedRequest = {
            proof: new Uint8Array([1, 2, 3, 4]),
            nullifier: randomBytes(32),
            commitment: changeCommitment,
            ciphertext: changeEncrypted.ciphertext,
            ephemeralKey: changeEncrypted.ephemeralPk,
            nonce: changeEncrypted.nonce,
          };
          
          const changeResponse = await client.apiClient.submitShielded(changeRequest);
          
          if (!changeResponse.accepted) {
            console.warn('Change note submission failed:', changeResponse.message);
          }
        }
        
        // Optimistic update for transparent balance
        if (transparentBalance !== null) {
          setTransparentBalance(transparentBalance + amountLamports);
        }
        
        setSuccess(`Unshielded ${amountNum.toFixed(4)} zeSOL! TX: ${response.txHash.slice(0, 16)}...`);
      }
      
      // Refresh balances
      setTimeout(() => {
        fetchBalances();
      }, 1500);
      
      // Clear form
      setAmount('');
      
    } catch (err: unknown) {
      const message = err instanceof Error ? err.message : 'Unknown error';
      setError(message);
    } finally {
      setSending(false);
    }
  };

  // Copy shielded address to clipboard
  const copyAddress = async () => {
    if (shieldedAddress) {
      await navigator.clipboard.writeText(shieldedAddress);
    }
  };

  // If wallet not connected
  if (!isReady) {
    return (
      <div className="flex flex-col items-center justify-center py-12 space-y-4">
        <div className="w-16 h-16 bg-purple-500/10 rounded-full flex items-center justify-center mb-2">
          <svg className="w-8 h-8 text-purple-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
          </svg>
        </div>
        <h3 className="text-lg font-medium text-white">Connect Wallet</h3>
        <p className="text-sm text-white/60 text-center max-w-sm">
          Connect your Solana wallet to use shielded transactions.
        </p>
      </div>
    );
  }

  return (
    <div className="space-y-5">
      {/* Tab Selector */}
      <div className="flex gap-2 p-1 bg-zinc-800/50 rounded-lg">
        <TabButton active={activeTab === 'shield'} onClick={() => setActiveTab('shield')}>
          Shield
        </TabButton>
        <TabButton active={activeTab === 'transfer'} onClick={() => setActiveTab('transfer')}>
          Transfer
        </TabButton>
        <TabButton active={activeTab === 'unshield'} onClick={() => setActiveTab('unshield')}>
          Unshield
        </TabButton>
      </div>

      {/* Balances Display */}
      <div className="grid grid-cols-2 gap-3">
        {/* Transparent Balance */}
        <div className="bg-zinc-800/50 rounded-xl p-3 border border-emerald-500/20">
          <div className="text-[10px] text-emerald-400/60 uppercase tracking-wider mb-1">Transparent zeSOL</div>
          <div className="flex items-baseline gap-1">
            <span className="text-lg font-semibold text-emerald-400">
              {transparentBalanceInSol.toFixed(4)}
            </span>
            <span className="text-xs text-emerald-400/40">zeSOL</span>
          </div>
        </div>
        
        {/* Shielded Balance */}
        <div className="bg-zinc-800/50 rounded-xl p-3 border border-purple-500/20">
          <div className="flex items-center justify-between mb-1">
            <span className="text-[10px] text-purple-400/60 uppercase tracking-wider">Shielded zeSOL</span>
            <button
              onClick={fetchShieldedBalance}
              disabled={balanceLoading}
              className="text-[10px] text-purple-400 hover:text-purple-300 disabled:opacity-50"
            >
              {balanceLoading ? '...' : 'Scan'}
            </button>
          </div>
          <div className="flex items-baseline gap-1">
            <span className="text-lg font-semibold text-purple-400">
              {balanceLoading ? '...' : shieldedBalanceInSol.toFixed(4)}
            </span>
            <span className="text-xs text-purple-400/40">zeSOL</span>
          </div>
          <div className="text-[10px] text-white/30 mt-0.5">
            {noteCount} note{noteCount !== 1 ? 's' : ''}
          </div>
        </div>
      </div>

      {/* Your Shielded Address */}
      <div className="bg-zinc-800/30 rounded-xl p-3 border border-white/5">
        <div className="flex items-center justify-between mb-1">
          <span className="text-[10px] text-white/40 uppercase tracking-wider">Your Shielded Address</span>
          <button
            onClick={copyAddress}
            className="text-[10px] text-purple-400 hover:text-purple-300 transition-colors"
          >
            Copy
          </button>
        </div>
        <div className="font-mono text-[10px] text-white/60 break-all">
          {shieldedAddress || 'Loading...'}
        </div>
      </div>

      {/* Tab Content */}
      {activeTab === 'shield' && (
        <div className="space-y-4">
          {/* Shield Info */}
          <div className="bg-emerald-500/10 border border-emerald-500/20 rounded-xl p-3">
            <div className="flex items-start gap-2">
              <svg className="w-4 h-4 text-emerald-400 flex-shrink-0 mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" />
              </svg>
              <div className="text-xs text-emerald-400/80">
                <span className="font-medium">Shield your zeSOL</span>
                <p className="text-emerald-400/60 mt-0.5">
                  Convert transparent balance to private shielded balance. Your funds become untraceable.
                </p>
              </div>
            </div>
          </div>

          {/* Amount Input */}
          <div>
            <label className="text-xs text-white/40 uppercase tracking-wider mb-2 block">
              Amount to Shield
            </label>
            <div className="flex gap-2">
              <input
                type="number"
                step="0.001"
                min="0"
                placeholder="0.0"
                value={amount}
                onChange={(e) => setAmount(e.target.value)}
                className="flex-1 px-4 py-3 rounded-xl bg-zinc-900 text-white text-lg border border-white/10 focus:outline-none focus:border-emerald-500/50 font-mono"
              />
              <button
                onClick={() => setAmount(transparentBalanceInSol.toFixed(4))}
                className="px-4 py-3 rounded-xl bg-white/5 text-white/60 text-sm hover:bg-white/10 transition-colors"
              >
                Max
              </button>
            </div>
          </div>

          {/* Submit Button */}
          <button
            onClick={handleShield}
            disabled={sending || !amount || parseFloat(amount) <= 0}
            className="w-full px-4 py-4 rounded-xl bg-gradient-to-r from-emerald-600 to-teal-600 text-white text-sm font-semibold shadow-lg shadow-emerald-500/20 disabled:opacity-40 disabled:shadow-none transition-all disabled:cursor-not-allowed"
          >
            {sending ? 'Shielding...' : 'Shield zeSOL'}
          </button>
        </div>
      )}

      {activeTab === 'transfer' && (
        <div className="space-y-4">
          {/* Transfer Info */}
          <div className="bg-purple-500/10 border border-purple-500/20 rounded-xl p-3">
            <div className="flex items-start gap-2">
              <svg className="w-4 h-4 text-purple-400 flex-shrink-0 mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
              </svg>
              <div className="text-xs text-purple-400/80">
                <span className="font-medium">Private Transfer</span>
                <p className="text-purple-400/60 mt-0.5">
                  Send shielded zeSOL to another shielded address. Amount and recipient are hidden.
                </p>
              </div>
            </div>
          </div>

          {/* Recipient Input */}
          <div>
            <label className="text-xs text-white/40 uppercase tracking-wider mb-2 block">
              Recipient Shielded Address
            </label>
            <input
              type="text"
              placeholder="64 hex characters"
              value={recipient}
              onChange={(e) => setRecipient(e.target.value)}
              className="w-full px-4 py-3 rounded-xl bg-zinc-900 text-white text-sm border border-white/10 focus:outline-none focus:border-purple-500/50 font-mono"
            />
          </div>

          {/* Amount Input */}
          <div>
            <label className="text-xs text-white/40 uppercase tracking-wider mb-2 block">
              Amount
            </label>
            <div className="flex gap-2">
              <input
                type="number"
                step="0.001"
                min="0"
                placeholder="0.0"
                value={amount}
                onChange={(e) => setAmount(e.target.value)}
                className="flex-1 px-4 py-3 rounded-xl bg-zinc-900 text-white text-lg border border-white/10 focus:outline-none focus:border-purple-500/50 font-mono"
              />
              <button
                onClick={() => setAmount(shieldedBalanceInSol.toFixed(4))}
                className="px-4 py-3 rounded-xl bg-white/5 text-white/60 text-sm hover:bg-white/10 transition-colors"
              >
                Max
              </button>
            </div>
          </div>

          {/* Submit Button */}
          <button
            onClick={handleTransfer}
            disabled={sending || !amount || parseFloat(amount) <= 0 || !recipient || !proverReady}
            className="w-full px-4 py-4 rounded-xl bg-gradient-to-r from-purple-600 to-pink-600 text-white text-sm font-semibold shadow-lg shadow-purple-500/20 disabled:opacity-40 disabled:shadow-none transition-all disabled:cursor-not-allowed"
          >
            {!proverReady ? 'Loading Prover...' : sending ? 'Sending...' : 'Send Privately'}
          </button>
        </div>
      )}

      {activeTab === 'unshield' && (
        <div className="space-y-4">
          {/* Unshield Info */}
          <div className="bg-yellow-500/10 border border-yellow-500/20 rounded-xl p-3">
            <div className="flex items-start gap-2">
              <svg className="w-4 h-4 text-yellow-400 flex-shrink-0 mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 11V7a4 4 0 118 0m-4 8v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2z" />
              </svg>
              <div className="text-xs text-yellow-400/80">
                <span className="font-medium">Unshield your zeSOL</span>
                <p className="text-yellow-400/60 mt-0.5">
                  Convert shielded balance back to transparent. Required for L1 withdrawals or transparent transfers.
                </p>
              </div>
            </div>
          </div>

          {/* Amount Input */}
          <div>
            <label className="text-xs text-white/40 uppercase tracking-wider mb-2 block">
              Amount to Unshield
            </label>
            <div className="flex gap-2">
              <input
                type="number"
                step="0.001"
                min="0"
                placeholder="0.0"
                value={amount}
                onChange={(e) => setAmount(e.target.value)}
                className="flex-1 px-4 py-3 rounded-xl bg-zinc-900 text-white text-lg border border-white/10 focus:outline-none focus:border-yellow-500/50 font-mono"
              />
              <button
                onClick={() => setAmount(shieldedBalanceInSol.toFixed(4))}
                className="px-4 py-3 rounded-xl bg-white/5 text-white/60 text-sm hover:bg-white/10 transition-colors"
              >
                Max
              </button>
            </div>
          </div>

          {/* Submit Button */}
          <button
            onClick={handleUnshield}
            disabled={sending || !amount || parseFloat(amount) <= 0 || !proverReady}
            className="w-full px-4 py-4 rounded-xl bg-gradient-to-r from-yellow-600 to-orange-600 text-white text-sm font-semibold shadow-lg shadow-yellow-500/20 disabled:opacity-40 disabled:shadow-none transition-all disabled:cursor-not-allowed"
          >
            {!proverReady ? 'Loading Prover...' : sending ? 'Unshielding...' : 'Unshield zeSOL'}
          </button>
        </div>
      )}

      {/* Error */}
      {(error || proverError) && (
        <div className="p-3 rounded-xl bg-red-500/10 border border-red-500/20 text-red-400 text-sm">
          {error || proverError}
        </div>
      )}

      {/* Success */}
      {success && (
        <div className="p-3 rounded-xl bg-emerald-500/10 border border-emerald-500/20 text-emerald-400 text-sm">
          {success}
        </div>
      )}

      {/* Dev Mode Notice */}
      <div className="bg-zinc-800/30 border border-white/5 rounded-xl p-3">
        <div className="flex items-start gap-2">
          <svg className="w-4 h-4 text-blue-400 flex-shrink-0 mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          <div className="text-[10px] text-white/50">
            <span className="font-medium text-blue-400/80"> Mode: </span> 
            In production, full ZK proofs will be generated and verified.
          </div>
        </div>
      </div>
    </div>
  );
}
